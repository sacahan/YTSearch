# 功能規範：YouTube 播放列表元數據提取

**功能分支**：`003-playlist-metadata`
**建立日期**：2025-12-08
**狀態**：草稿
**輸入**：使用者描述：獲取指定 YouTube 播放列表中的所有歌曲 metadata，其中以歌曲名稱為必要，僅使用 YouTube 網頁 URL（例如：<https://www.youtube.com/watch?v=9tjdswqGGVg&list=PLuOOH93liK-tJiMmA6zW8PdwTmgc4k6bq>）不使用 YouTube Data API 以節省成本

**語言**：本文件及所有 `/speckit` 產出必須使用正體中文撰寫

## 用戶情景與測試 *(必須)*

### 用戶故事 1 - 播放列表 URL 解析與驗證（優先級：P1）

系統提供 API 端點接受 YouTube 播放列表 URL，解析列表 ID，驗證 URL 格式和有效性，並返回播放列表的基本資訊。

**為何此優先級**：這是核心功能，系統必須能夠從 URL 中正確提取播放列表 ID，否則無法進行後續的歌曲提取操作。

**獨立測試**：可直接呼叫新 API 端點傳入有效的播放列表 URL，驗證是否返回含有播放列表資訊（如播放列表 ID、標題、歌曲計數）的 JSON 回應。

**接受情景**：

1. **當** 客戶端呼叫新端點並提供有效的播放列表 URL（例如 `https://www.youtube.com/watch?v=9tjdswqGGVg&list=PLuOOH93liK-tJiMmA6zW8PdwTmgc4k6bq`）**則** 系統返回 HTTP 200 且成功解析播放列表 ID
2. **當** URL 包含有效的播放列表 ID 參數 `list=` **則** 系統應提取該 ID 並返回
3. **當** 提供無效或格式不正確的 URL **則** 系統返回 HTTP 400 Bad Request，並提示錯誤原因
4. **當** 提供的播放列表不存在或無法訪問 **則** 系統返回 HTTP 404 Not Found

---

### 用戶故事 2 - 播放列表歌曲元數據提取（優先級：P1）

系統從 YouTube 播放列表中提取所有歌曲的 metadata，包括必需的歌曲名稱，以及其他可用的 metadata（視頻 ID、頻道、發佈日期、觀看次數、時長等），並以標準化格式返回完整清單。

**為何此優先級**：歌曲 metadata 提取是本功能的核心價值主張。無法有效提取歌曲資訊（尤其是歌曲名稱）就無法滿足用戶需求。

**獨立測試**：搜尋播放列表後檢查回應中每首歌曲都包含必需的 `title`（歌曲名稱）欄位，以及盡可能多的可選 metadata。應能成功提取至少 80% 的歌曲資訊。

**接受情景**：

1. **當** 系統掃描播放列表 **則** 每首歌曲至少包含 `title`（歌曲名稱）和 `video_id` 欄位
2. **當** 歌曲頁面提供相關資訊 **則** 應包含 `channel`（頻道/藝術家）欄位
3. **當** 歌曲資訊可用 **則** 應包含 `url`、`publish_date`、`duration` 欄位
4. **當** 播放列表包含多首歌曲 **則** 系統應返回所有歌曲（支援分頁或一次性返回，具體由實現決定）
5. **當** 歌曲無法提取資訊時 **則** 系統應跳過該歌曲或返回部分可用資訊，而非中止整個操作

---

### 用戶故事 3 - 網頁爬取與成本優化（優先級：P1）

系統使用網頁爬取方式（而非 YouTube Data API）從 YouTube 頁面提取播放列表及歌曲資訊，確保零成本運行，並實現與現有搜尋功能的一致性。

**為何此優先級**：無 API 成本是本功能的核心賣點，必須從一開始就確保實現方式正確以符合成本目標。

**獨立測試**：驗證系統不調用任何 YouTube Data API，而是通過 HTTP 請求和 HTML 爬取完成整個操作。監控網絡請求確認所有請求都指向 youtube.com 頁面，無 googleapis.com 調用。

**接受情景**：

1. **當** 系統提取播放列表資訊 **則** 應使用網頁爬取而非 API 調用
2. **當** 系統運行時 **則** 不應發起任何 YouTube Data API 請求
3. **當** 網頁內容發生變化 **則** 爬取邏輯應具有一定的容錯能力，而非脆性失敗

---

### 用戶故事 4 - 播放列表結果排序與過濾（優先級：P2）

API 支援對播放列表中的歌曲進行排序（如按標題、發佈日期或在播放列表中的位置排序）和過濾（如按頻道、日期範圍或歌曲名稱關鍵字過濾）。

**為何此優先級**：增強結果查詢靈活性。P1 功能完成後，P2 優化用戶體驗與查詢效率。

**獨立測試**：在提取播放列表後，可進行排序和過濾操作，驗證返回的歌曲清單按指定方式組織和篩選。

**接受情景**：

1. **當** 客戶端指定排序方式 **則** 系統返回按該方式排序的歌曲清單
2. **當** 客戶端指定過濾條件（如關鍵字） **則** 系統只返回符合條件的歌曲
3. **當** 無排序或過濾指定 **則** 系統返回原始播放列表順序

---

### 用戶故事 5 - 播放列表緩存與性能優化（優先級：P2）

系統實現播放列表元數據的緩存機制，減少重複爬取相同播放列表的成本，提升性能。

**為何此優先級**：性能優化功能，P1 功能穩定後實施，提升用戶體驗。

**獨立測試**：同一播放列表的連續查詢應使用緩存，第二次查詢應比第一次更快。可配置緩存過期時間。

**接受情景**：

1. **當** 播放列表首次查詢 **則** 系統進行爬取並將結果緩存
2. **當** 相同播放列表在緩存有效期內再次查詢 **則** 系統返回緩存結果，無需重新爬取
3. **當** 緩存過期 **則** 系統重新爬取最新資料

---

### 邊界情況

- 播放列表包含非音樂視頻時系統如何處理？（系統應返回所有視頻，由用戶過濾）
- 播放列表為私密或受限時系統如何處理？（系統應返回 403 或類似錯誤）
- 播放列表包含超過 1000 首歌曲時系統如何處理？（系統應支援分頁或流式返回）
- YouTube 更改頁面結構導致爬取失敗時系統如何處理？（應返回明確的錯誤訊息便於除錯）
- 同時查詢多個播放列表時的性能和資源使用？（應有合理的並發限制）

## 功能需求 *(必須)*

### 功能需求

- **FR-001**：系統必須接受 YouTube 播放列表 URL 作為輸入，並從中提取播放列表 ID
- **FR-002**：系統必須驗證提供的播放列表 URL 格式有效性，無效格式應返回適當的錯誤訊息
- **FR-003**：系統必須通過網頁爬取（不使用 YouTube Data API）獲取播放列表中每首歌曲的元數據
- **FR-004**：系統必須為每首歌曲提取並返回 `title`（歌曲名稱）欄位（必需）
- **FR-005**：系統應提取並返回 `video_id`、`channel`、`url`、`publish_date`、`duration` 等可選元數據
- **FR-006**：系統必須返回播放列表中所有歌曲的完整清單（支援適當的分頁或流式處理機制）
- **FR-007**：系統必須實現對歌曲清單的排序功能（支援按標題、發佈日期、播放列表位置排序）
- **FR-008**：系統應實現對歌曲清單的過濾功能（如按關鍵字、頻道、日期範圍過濾）
- **FR-009**：系統應實現播放列表元數據的緩存機制，減少重複爬取
- **FR-010**：系統應具有適當的錯誤處理和日誌記錄機制，便於問題診斷和系統監控
- **FR-011**：系統不應調用任何 YouTube Data API，所有資訊應通過網頁爬取獲得
- **FR-012**：當爬取失敗或頁面結構變更時，系統應返回明確的錯誤訊息而非模糊的異常

### 關鍵實體

- **播放列表（Playlist）**：代表一個 YouTube 播放列表，具有 ID、URL、標題、歌曲計數等屬性
- **歌曲（Track/Video）**：播放列表中的單首歌曲/視頻，具有 video_id、title、channel、url、publish_date、duration、view_count 等屬性
- **元數據（Metadata）**：歌曲的各類資訊，包括必需（title）和可選（video_id、channel、url、publish_date、duration 等）欄位

## 成功標準 *(必須)*

### 可測量的成果

- **SC-001**：系統能夠正確解析 YouTube 播放列表 URL，提取列表 ID，成功率 ≥ 99%
- **SC-002**：系統能夠從播放列表中提取所有歌曲的 `title` 欄位，成功率 ≥ 95%
- **SC-003**：系統能夠從播放列表中提取歌曲的其他可選元數據（video_id、channel 等），成功率 ≥ 80%
- **SC-004**：系統提取一個包含 50 首歌曲的播放列表的耗時 ≤ 30 秒
- **SC-005**：系統對同一播放列表的第二次查詢（使用緩存）的耗時 ≤ 500 毫秒
- **SC-006**：系統的錯誤回應（如 400、404）應清晰說明錯誤原因，幫助用戶理解問題
- **SC-007**：系統支援至少 100 個並發播放列表查詢請求，無明顯性能降級
- **SC-008**：所有功能應不依賴 YouTube Data API，完全通過網頁爬取實現

## 假設與依賴

- 系統假設 YouTube 頁面結構在短期內保持相對穩定，但應設計為易於適應未來的結構變更
- 系統假設有效的播放列表 URL 至少包含 `list=` 參數用於標識播放列表
- 系統假設網絡環境穩定，超時處理應合理（建議 15-30 秒）
- 系統應與現有的 Redis 緩存基礎設施相集成
- 系統應遵循現有的代碼結構和設計模式（如 Service 層架構、錯誤處理方式）

## 技術約束

- **語言**：必須使用 Python（與現有代碼庫一致）
- **架構**：必須遵循現有的 Service 層模式和 FastAPI 路由設計
- **API 成本**：絕對禁止使用 YouTube Data API，所有功能必須通過網頁爬取實現
- **兼容性**：新功能不應修改現有的 search API，應作為新端點添加

## 下一步

1. 通過 `/speckit.clarify` 命令確認是否有需要澄清的需求
2. 在確認無誤後，使用 `/speckit.plan` 命令生成詳細的實現計畫
3. 根據計畫進行功能開發和測試
